package keys

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"encoding/base64"
	"io/ioutil"
	"testing"

	"github.com/dgrijalva/jwt-go"
)

// CACert is path to the CA certificate.
// This should be generated by Makefile before test.
const TLSCACert = "keys/testdata/ca.crt"

// ServerCert is path to the server certificate.
// This should be generated by Makefile before test.
const TLSServerCert = "keys/testdata/server.crt"

// ServerKey is path to the server key.
// This should be generated by Makefile before test.
const TLSServerKey = "keys/testdata/server.key"

// TLSConfig returns a TLS config with the CA cert.
func TLSConfig(t *testing.T) *tls.Config {
	t.Helper()
	p := x509.NewCertPool()
	b, err := ioutil.ReadFile(TLSCACert)
	if err != nil {
		t.Fatalf("could not read the CA cert: %s", err)
	}
	if !p.AppendCertsFromPEM(b) {
		t.Fatalf("could not append the CA cert")
	}
	return &tls.Config{
		RootCAs: p,
	}
}

// Base64TLSCACert returns a base64 encoded string of the CA cert.
func Base64TLSCACert(t *testing.T) string {
	b, err := ioutil.ReadFile(TLSCACert)
	if err != nil {
		t.Fatalf("could not read the CA cert: %s", err)
	}
	return base64.StdEncoding.EncodeToString(b)
}

func New(t *testing.T) Keys {
	t.Helper()
	k, err := rsa.GenerateKey(rand.Reader, 1024)
	if err != nil {
		t.Fatalf("Could not generate a key pair: %s", err)
	}
	return Keys{
		IDTokenKeyPair: k,
	}
}

type Keys struct {
	IDTokenKeyPair *rsa.PrivateKey // a key pair for signing ID tokens
}

func (c *Keys) SignClaims(t *testing.T, claims jwt.Claims) string {
	t.Helper()
	token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
	s, err := token.SignedString(c.IDTokenKeyPair)
	if err != nil {
		t.Fatalf("Could not sign the claims: %s", err)
	}
	return s
}
