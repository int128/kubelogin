package keys

import (
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"encoding/base64"
	"encoding/pem"
	"io/ioutil"

	"golang.org/x/xerrors"
)

// TLSCACert is path to the CA certificate.
// This should be generated by Makefile before test.
const TLSCACert = "keys/testdata/ca.crt"

// TLSCACertAsBase64 is a base64 encoded string of TLSCACert.
var TLSCACertAsBase64 string

// TLSCACertAsConfig is a TLS config including TLSCACert.
var TLSCACertAsConfig = &tls.Config{RootCAs: x509.NewCertPool()}

// TLSServerCert is path to the server certificate.
// This should be generated by Makefile before test.
const TLSServerCert = "keys/testdata/server.crt"

// TLSServerKey is path to the server key.
// This should be generated by Makefile before test.
const TLSServerKey = "keys/testdata/server.key"

// JWSKey is path to the key for signing ID tokens.
const JWSKey = "keys/testdata/jws.key"

// JWSKeyPair is the key pair loaded from JWSKey.
var JWSKeyPair *rsa.PrivateKey

func init() {
	var err error
	JWSKeyPair, err = readPrivateKey(JWSKey)
	if err != nil {
		panic(err)
	}
	b, err := ioutil.ReadFile(TLSCACert)
	if err != nil {
		panic(err)
	}
	TLSCACertAsBase64 = base64.StdEncoding.EncodeToString(b)
	if !TLSCACertAsConfig.RootCAs.AppendCertsFromPEM(b) {
		panic("could not append the CA cert")
	}
}

func readPrivateKey(name string) (*rsa.PrivateKey, error) {
	b, err := ioutil.ReadFile(name)
	if err != nil {
		return nil, xerrors.Errorf("could not read JWSKey: %w", err)
	}
	block, rest := pem.Decode(b)
	if block == nil {
		return nil, xerrors.New("could not decode PEM")
	}
	if len(rest) > 0 {
		return nil, xerrors.New("PEM should contain single key but multiple keys")
	}
	k, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		return nil, xerrors.Errorf("could not parse the key: %w", err)
	}
	return k, nil
}
