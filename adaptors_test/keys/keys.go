package keys

import (
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"encoding/base64"
	"encoding/pem"
	"io/ioutil"
	"testing"

	"github.com/pkg/errors"
)

// CACert is path to the CA certificate.
// This should be generated by Makefile before test.
const TLSCACert = "keys/testdata/ca.crt"

// ServerCert is path to the server certificate.
// This should be generated by Makefile before test.
const TLSServerCert = "keys/testdata/server.crt"

// ServerKey is path to the server key.
// This should be generated by Makefile before test.
const TLSServerKey = "keys/testdata/server.key"

// JWSKey is path to the key for signing ID tokens.
const JWSKey = "keys/testdata/jws.key"

// JWSKeyPair is the key pair loaded from JWSKey.
var JWSKeyPair *rsa.PrivateKey

func init() {
	var err error
	JWSKeyPair, err = readPrivateKey(JWSKey)
	if err != nil {
		panic(err)
	}
}

func readPrivateKey(name string) (*rsa.PrivateKey, error) {
	b, err := ioutil.ReadFile(name)
	if err != nil {
		return nil, errors.Wrapf(err, "could not read JWSKey")
	}
	block, rest := pem.Decode(b)
	if block == nil {
		return nil, errors.New("could not decode PEM")
	}
	if len(rest) > 0 {
		return nil, errors.New("PEM should contain single key but multiple keys")
	}
	k, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		return nil, errors.Wrapf(err, "could not parse the key")
	}
	return k, nil
}

// TLSConfig returns a TLS config with the CA cert.
func TLSConfig(t *testing.T) *tls.Config {
	t.Helper()
	p := x509.NewCertPool()
	b, err := ioutil.ReadFile(TLSCACert)
	if err != nil {
		t.Fatalf("could not read the CA cert: %s", err)
	}
	if !p.AppendCertsFromPEM(b) {
		t.Fatalf("could not append the CA cert")
	}
	return &tls.Config{
		RootCAs: p,
	}
}

// Base64TLSCACert returns a base64 encoded string of the CA cert.
func Base64TLSCACert(t *testing.T) string {
	t.Helper()
	b, err := ioutil.ReadFile(TLSCACert)
	if err != nil {
		t.Fatalf("could not read the CA cert: %s", err)
	}
	return base64.StdEncoding.EncodeToString(b)
}
