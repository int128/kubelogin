package keys

import (
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"encoding/pem"
	"io/ioutil"
)

// Keys represents a pair of certificate and key.
type Keys struct {
	CertPath   string
	KeyPath    string
	CACertPath string
	TLSConfig  *tls.Config
}

// None represents non-TLS.
var None Keys

// Server is a Keys for TLS server.
// These files should be generated by Makefile before test.
var Server = Keys{
	CertPath:   "keys/testdata/server.crt",
	KeyPath:    "keys/testdata/server.key",
	CACertPath: "keys/testdata/ca.crt",
	TLSConfig:  newTLSConfig("keys/testdata/ca.crt"),
}

// JWSKey is path to the key for signing ID tokens.
// This file should be generated by Makefile before test.
const JWSKey = "keys/testdata/jws.key"

// JWSKeyPair is the key pair loaded from JWSKey.
var JWSKeyPair = readPrivateKey(JWSKey)

func newTLSConfig(name string) *tls.Config {
	b, err := ioutil.ReadFile(name)
	if err != nil {
		panic(err)
	}
	p := x509.NewCertPool()
	if !p.AppendCertsFromPEM(b) {
		panic("could not append the CA cert")
	}
	return &tls.Config{RootCAs: p}
}

func readPrivateKey(name string) *rsa.PrivateKey {
	b, err := ioutil.ReadFile(name)
	if err != nil {
		panic(err)
	}
	block, rest := pem.Decode(b)
	if block == nil {
		panic("could not decode PEM")
	}
	if len(rest) > 0 {
		panic("PEM should contain single key but multiple keys")
	}
	k, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		panic(err)
	}
	return k
}
