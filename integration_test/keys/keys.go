package keys

import (
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"encoding/base64"
	"encoding/pem"
	"io"
	"io/ioutil"
	"os"
	"strings"
)

// Keys represents a pair of certificate and key.
type Keys struct {
	CertPath     string
	KeyPath      string
	CACertPath   string
	CACertBase64 string
	TLSConfig    *tls.Config
}

// None represents non-TLS.
var None Keys

// Server is a Keys for TLS server.
// These files should be generated by Makefile before test.
var Server = Keys{
	CertPath:     "keys/testdata/server.crt",
	KeyPath:      "keys/testdata/server.key",
	CACertPath:   "keys/testdata/ca.crt",
	CACertBase64: readAsBase64("keys/testdata/ca.crt"),
	TLSConfig:    newTLSConfig("keys/testdata/ca.crt"),
}

// JWSKey is path to the key for signing ID tokens.
// This file should be generated by Makefile before test.
const JWSKey = "keys/testdata/jws.key"

// JWSKeyPair is the key pair loaded from JWSKey.
var JWSKeyPair = readPrivateKey(JWSKey)

func readAsBase64(name string) string {
	f, err := os.Open(name)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	var s strings.Builder
	e := base64.NewEncoder(base64.StdEncoding, &s)
	if _, err := io.Copy(e, f); err != nil {
		panic(err)
	}
	if err := e.Close(); err != nil {
		panic(err)
	}
	return s.String()
}

func newTLSConfig(name string) *tls.Config {
	b, err := ioutil.ReadFile(name)
	if err != nil {
		panic(err)
	}
	p := x509.NewCertPool()
	if !p.AppendCertsFromPEM(b) {
		panic("could not append the CA cert")
	}
	return &tls.Config{RootCAs: p}
}

func readPrivateKey(name string) *rsa.PrivateKey {
	b, err := ioutil.ReadFile(name)
	if err != nil {
		panic(err)
	}
	block, rest := pem.Decode(b)
	if block == nil {
		panic("could not decode PEM")
	}
	if len(rest) > 0 {
		panic("PEM should contain single key but multiple keys")
	}
	k, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		panic(err)
	}
	return k
}
